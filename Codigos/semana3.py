# -*- coding: utf-8 -*-
"""Semana3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WJ_GnEazKfQieeD9ZEeTV8S4j1vnLxr0
"""

import sympy as sp
from sympy import *
import numpy as np
import mpmath
from functools import lru_cache
from IPython.display import display, Math
import matplotlib.pyplot as plt

# Variable simbólica
x = sp.Symbol('x', real=True)

@lru_cache(maxsize=None)
def prod_int_Ch(f, g):
    return sp.integrate(f*g*sp.sqrt(1-x**2), (x, -1, 1))

@lru_cache(maxsize=None)
def prod_int_L(f, g):
    return sp.integrate(f*g, (x, -1, 1))

# ---------------------------
# Función Gram-Schmidt
# ---------------------------
def gram_schmidt(base, prod_int, ortonormal=True):
    """
    base: lista de funciones simbólicas
    prod_int: función de producto interno
    ortonormal: True para ortonormalizar, False para solo ortogonalizar
    """
    ortogonal = []
    normas = []

    for vi in base:
        wi = vi
        for u, nrm in zip(ortogonal, normas):
            wi -= prod_int(wi, u) / (nrm if not ortonormal else nrm**2) * u

        norma_wi = sp.sqrt(prod_int(wi, wi))

        if ortonormal:
            wi = wi / norma_wi
            normas.append(1)
        else:
            normas.append(norma_wi)

        ortogonal.append(sp.simplify(sp.expand(wi)))

    return ortogonal, normas

# ---------------------------
# Construcción de bases
# ---------------------------
n = 10
base = [x**i for i in range(n+1)]

# Base de Chebyshev
chebyshev, normas_Ch = gram_schmidt(base, prod_int_Ch, ortonormal=True)

# Base de Legendre
legendre, normas_L = gram_schmidt(base, prod_int_L, ortonormal=True)

# ---------------------------
# Mostrar resultados simplificados
# ---------------------------
for i, p in enumerate(chebyshev):
    display(Math(f"T_{{{i}}}(x) = {sp.latex(sp.simplify(sp.expand(p)))}"))

for i, p in enumerate(legendre):
    display(Math(f"P_{{{i}}}(x) = {sp.latex(sp.simplify(sp.expand(p)))}"))

# Definir la función objetivo
h = sp.sin(3*x) * (1 - x**2)


# Productos internos con la base original
proy_LM = [prod_int_L(h, p) for p in base]
producto_LM = [a*b for a, b in zip(base, proy_LM)]
print()
proy_L = [prod_int_L(h, p) for p in legendre]
producto_legendre = [a*b for a, b in zip(legendre, proy_L)]


expansion_legendre = sp.simplify(sum(producto_legendre))
expansion_LM =sp.simplify( sum(producto_LM))

producto_LM_simplificado = [sp.simplify(term) for term in producto_LM]
producto_legendre_simplificado = [sp.simplify(term) for term in producto_legendre]

# Mostrar resultados
display(Math(f"\\text{{Expansión en polinomios:}} {sp.latex(producto_LM_simplificado)}"))
print()
display(Math(f"\\text{{Expansión en polinomios de Legendre:}} {sp.latex(producto_legendre_simplificado)}"))
print()

#usamos integral numerica
@lru_cache(maxsize=None)
def prod_int_ChN(f, g):
    integrand = sp.lambdify(x, f*g*sp.sqrt(1-x**2), 'mpmath')
    return mpmath.quad(integrand, [-1, 1])

# Proyecciones con base de Chebyshev y su expansión
proy_Ch = [prod_int_ChN(h, p) for p in chebyshev]
producto_chebyshev = [a*b for a, b in zip(chebyshev, proy_Ch)]

# Expresión completa de la aproximación
aprox_chebyshev = sum(producto_chebyshev)

# Simplificar cada término
producto_chebyshev_simplificado = [sp.simplify(term) for term in producto_chebyshev]

# Mostrar expansión
display(Math(f"\\text{{Expansión en polinomios de Chebyshev:}} {sp.latex(producto_chebyshev_simplificado)}"))

indices = [1, 3, 5, 7, 9, 11]

def evaluar_punto_a_punto(expr, X):
    f_num = sp.lambdify(x, expr, 'numpy')
    return np.array([float(f_num(xi)) for xi in X])  # Evalúa cada punto

def graficar_parciales(producto, titulo):
    plt.figure(figsize=(8, 6))
    plt.plot(X, Y_h, 'k', linewidth=2, label='h(x) Original')

    for k in indices:
        parcial = sp.simplify(sum(producto[:k]))
        Y_parcial = evaluar_punto_a_punto(parcial, X)
        plt.plot(X, Y_parcial, linewidth=1.5, label=f'{k} términos')

    plt.xlabel('x')
    plt.ylabel('y')
    plt.title(f'Aproximación progresiva - {titulo}')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

graficar_parciales(producto_LM, "Base de Monomios")
graficar_parciales(producto_legendre, "Polinomios de Legendre")
graficar_parciales(producto_chebyshev, "Polinomios de Chebyshev")

indices = [1, 3, 5, 7, 9, 11]

# --- Calcular errores progresivos para cada método ---
errores_LM = []
errores_Legendre = []
errores_Chebyshev = []

for k in indices:
    # LM
    parcial_LM = sp.simplify(sum(producto_LM[:k]))
    err_LM = sp.sqrt(prod_int_L(h - parcial_LM, h - parcial_LM)).evalf()
    errores_LM.append(err_LM)

    # Legendre
    parcial_Leg = sp.simplify(sum(producto_legendre[:k]))
    err_Leg = sp.sqrt(prod_int_L(h - parcial_Leg, h - parcial_Leg)).evalf()
    errores_Legendre.append(err_Leg)

    # Chebyshev (numérico)
    parcial_Cheb = sp.simplify(sum(producto_chebyshev[:k]))
    err_Cheb = sp.sqrt(prod_int_ChN(h - parcial_Cheb, h - parcial_Cheb))
    errores_Chebyshev.append(err_Cheb)

# Mostrar resultados
for k, e_LM, e_Leg, e_Cheb in zip(indices, errores_LM, errores_Legendre, errores_Chebyshev):
    display(Math(f"\\text{{Error Monomios    (k={k}): }} {e_LM}"))
    display(Math(f"\\text{{Error Legendre   (k={k}): }}  {e_Leg}"))
    display(Math(f"\\text{{Error Chebyshev (k={k}): }} {e_Cheb}"))
    print()